# -*- coding: utf-8 -*-
"""Aivazov Vizualization task 2 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aG_QIjuB_or1vbI65Wq8ZeCdj0VzfR4J

# Задание № 2. Визуализация ациклических графов
"""

import networkx as nx
import matplotlib.pyplot as plt
from statistics import median
from math import floor
import numpy as np
from scipy.optimize import linprog

tr1 = """<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"  
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
  http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <graph id="G" edgedefault="directed">
    <node id="n1"/>
    <node id="n2"/>
    <node id="n3"/>
    <node id="n4"/>
    <node id="n5"/>
    <node id="n6"/>
    <node id="n7"/>
    <node id="n8"/>
    <node id="n9"/>
    <node id="n10"/>
    <node id="n11"/>
    <node id="n12"/>
    <node id="n13"/>
    <edge source="n1" target="n4"/>
    <edge source="n1" target="n3"/>
    <edge source="n4" target="n8"/>
    <edge source="n5" target="n9"/>
    <edge source="n10" target="n12"/>
    <edge source="n10" target="n11"/>
    <edge source="n4" target="n6"/>
    <edge source="n4" target="n9"/>
    <edge source="n4" target="n7"/>
    <edge source="n3" target="n8"/>
    <edge source="n3" target="n10"/>
    <edge source="n3" target="n5"/>
    <edge source="n8" target="n10"/>
    <edge source="n9" target="n12"/>
    <edge source="n7" target="n11"/>
    <edge source="n12" target="n13"/>
    <edge source="n11" target="n13"/>
  </graph>
</graphml>"""

with open('./tr1.xml', 'w') as file:
    file.write(tr1)

class DiGraph:
    def __init__(self, path):
        self.G = nx.read_graphml(path)
        self.num_dict = dict()
        
        self.layers = [[]]
        
        for node in self.G.nodes:  # Инициализируем переменные для вершин
            self.G.nodes[node]['pred_arr'] = [1e6 for _ in range(len(self.G.pred[node]))]
            self.G.nodes[node]['layer'] = None
            self.G.nodes[node]['is_dummy'] = False
            self.G.nodes[node]['label'] = node
            self.G.nodes[node]['x'] = 0.0
            
    def visualize(self, max_width=None):
        self.top_sort()  # topological sort
        self.G = nx.relabel_nodes(self.G, self.num_dict)  # renaming nodes after sort
        
        if max_width is not None:
            # Graham - Coffman Algorithm
            self.assign_layers(W=max_width)
        else:
            # Min dummy vertices algorithm
            self.find_inital_layers()
            self.discretise()
        
        self.create_dummy_nodes()  
        self.generate_start_x()  # horizontal coords to nodes
        self.fix_layers()  # minimizing edges intersections
        self.beautify_x()  # Отцентрируем граф
    
    def top_sort(self):
        """Топологическая сортировка"""
        num = 0
        elem_generator = self.sort_generator()
        for _ in range(self.G.number_of_nodes()):
            node = next(elem_generator)
            self.num_dict[node] = num
            for succ_node in self.G.succ[node]:
                self.G.nodes[succ_node]['pred_arr'] = sorted(
                    self.G.nodes[succ_node]['pred_arr'][1:] + [num],
                    reverse=True
                )
            num += 1
            

    def node_min_check(self, node1, node2):
        """Проверяет является ли вершина node1 меньше node2 лексикографически"""
        node1_arr = self.G.nodes[node1]['pred_arr']
        node2_arr = self.G.nodes[node2]['pred_arr']
        
        for i in range(min(len(node1_arr), len(node2_arr))):
            if node1_arr[i] != node2_arr[i]:
                return node1_arr[i] > node2_arr[i]

        return len(node1_arr) > len(node2_arr)
   
    def sort_generator(self):
        """Генератор вершин для функции топологической сортировки"""
        for node in self.G.nodes:
            if len(self.G.pred[node]) == 0:
                yield node
        while True:
            min_node = None
            for node in self.G.nodes:
                if node not in self.num_dict.keys():
                    if min_node is None:
                        min_node = node
                    elif self.node_min_check(min_node, node):
                        min_node = node
            yield min_node
        
    def assign_layers(self, W):     
        """Присвоение уровня вершинам графа"""
        elem_generator = self.assign_layer_generator()
        for _ in range(self.G.number_of_nodes()):
            node = next(elem_generator)
            if len(self.G.succ[node]) > 0:
                layer_num = max([self.G.nodes[succ]['layer'] for succ in self.G.succ[node]]) + 1
            else:
                layer_num = 0
            
            while True:
                if layer_num == len(self.layers):
                    self.layers.append([])
                if len(self.layers[layer_num]) == W:
                    layer_num += 1
                else:
                    break

            self.layers[layer_num].append(node)
            self.G.nodes[node]['layer'] = layer_num

    def assign_layer_generator(self):
        """Генератор вершин для присвоения номера уровня"""
        while True:
            yield_node = None
            for node in reversed(range(len(self.G.nodes))):
                if self.G.nodes[node]['layer'] is not None:
                    continue
                has_unlayered_succs = any([self.G.nodes[succ]['layer'] is None for succ in self.G.succ[node]])
                if has_unlayered_succs:
                    continue
                yield_node = node
                break
            yield yield_node
            
    def find_inital_layers(self):
        """Решение задачи линейного программирования для нахождения начального приближения уровней"""
        n = len(self.G.nodes)
        m = len(self.G.edges)
        c = np.zeros(n)
        for u, v in self.G.edges:
            c[u] += 1
            c[v] -= 1
        
        A = np.zeros((m, n))
        b = np.zeros(m)
        for i, (u, v) in enumerate(self.G.edges):
            A[i, u] = -1
            A[i, v] = 1
            b[i] = -1
        bounds = [(0, None) for _ in self.G.nodes]
        layers = linprog(c, A_ub=A, b_ub=b, bounds=bounds)['x']
        
        for i, layer in enumerate(layers - np.min(layers)):
            self.G.nodes[i]['layer'] = layer
    
    def discretise(self):
        """Дискретизация уровней вершин с учетом минимизации числа dummy-вершин"""
        nodes = sorted(self.G.nodes, key=lambda node: self.G.nodes[node]['layer'])
        for node in nodes:
            if len(self.G.succ[node]) > 0:
                self.G.nodes[node]['layer'] = int(max([
                    self.G.nodes[succ]['layer'] for succ in self.G.succ[node]
                ])) + 1 
            else:
                self.G.nodes[node]['layer'] = 0
        for node in nodes:
            if len(self.G.succ[node]) <= len(self.G.pred[node]) and len(self.G.pred[node]) != 0:
                self.G.nodes[node]['layer'] = min([self.G.nodes[pred]['layer'] for pred in self.G.pred[node]]) - 1
                
        num_layers = max([self.G.nodes[node]['layer'] for node in self.G.nodes])
        self.layers = [[] for _ in range(num_layers+1)]
        for node in self.G.nodes:
            self.layers[self.G.nodes[node]['layer']].append(node)        
                    
    def generate_start_x(self):
        """Генерация начального приближения горизонтальных координат для вершин"""
        for layer in reversed(self.layers):
            for node in layer:
                x_preds = [self.G.nodes[pred]['x'] for pred in self.G.pred[node]]
                if len(x_preds) > 0:
                    self.G.nodes[node]['x'] = floor(median(x_preds))
                else:
                    self.G.nodes[node]['x'] = 0
                
            layer_sorted = sorted(layer, key=lambda x: self.G.nodes[x]['x'])
            for i in range(len(layer_sorted)-1):
                node1 = layer_sorted[i]
                for j in range(i+1, len(layer_sorted)):
                    node2 = layer_sorted[j]
                    if self.G.nodes[node1]['x'] == self.G.nodes[node2]['x']:
                        self.G.nodes[node2]['x'] += 1
                
    def calc_intersections(self, layer_num):
        """Подсчет количества пересечений ребер между вершинами из layer_num и layer_num-1 слоев"""
        layer = self.layers[layer_num]
        intersections = 0
        for node_i in layer:
            x_i = self.G.nodes[node_i]['x']
            for node_j in layer:
                x_j = self.G.nodes[node_j]['x']
                if x_i < x_j:
                    for node_k in self.G.succ[node_i]:
                        x_k = self.G.nodes[node_k]['x']
                        for node_l in self.G.succ[node_j]:
                            x_l = self.G.nodes[node_l]['x']
                            if x_k > x_l:
                                intersections += 1
        return intersections
    
    def create_dummy_nodes(self):
        edges_list = list(self.G.edges).copy()
        for u, v in edges_list:
            y_u, y_v = self.G.nodes[u]['layer'], self.G.nodes[v]['layer']            
            if y_u - y_v > 1:
                chain = [u]
                for i in reversed(range(y_v + 1, y_u)):
                    new_node_id = len(self.G.nodes)
                    self.G.add_node(new_node_id, layer=i, pred_arr=[], is_dummy=True, label=None, x=0.0)
                    chain.append(new_node_id)
                    self.layers[i].append(new_node_id)
                chain.append(v)
                self.G.remove_edge(u, v)
                for i in range(len(chain)-1):
                    self.G.add_edge(chain[i], chain[i+1])

    def apply_x(self, x_arr, layer_id):
        for x, node in zip(x_arr, self.layers[layer_id]):
            self.G.nodes[node]['x'] = x
    
    def find_min_intersections(self, layer_id):
        min_intersections = self.calc_intersections(layer_id) + self.calc_intersections(layer_id + 1)
        min_x_arr = [self.G.nodes[node]['x'] for node in self.layers[layer_id]]
        
        can_improve = True
        while can_improve:
            can_improve = False
            min_x_arr_step = min_x_arr.copy()
            
            for i in range(len(self.layers[layer_id]) - 1):
                for j in range(i + 1, len(self.layers[layer_id])):
                    x_arr = min_x_arr.copy()
                    x_arr[i], x_arr[j] = x_arr[j], x_arr[i]
                    self.apply_x(x_arr, layer_id)
                    
                    new_intersections = self.calc_intersections(layer_id) + self.calc_intersections(layer_id + 1)
                    if new_intersections < min_intersections:
                        min_intersections = new_intersections
                        min_x_arr_step = x_arr
                        can_improve = True
                    self.apply_x(min_x_arr, layer_id)
            
            min_x_arr = min_x_arr_step
            self.apply_x(min_x_arr, layer_id)
        return can_improve
        
    def fix_layers(self):
        for _ in range(10):
            results = []
            for layer_id in range(1, len(self.layers)-1):
                results.append(self.find_min_intersections(layer_id))
            
            for layer_id in reversed(range(1, len(self.layers)-1)):
                results.append(self.find_min_intersections(layer_id))
            if any(results) == False:
                break
            
    def beautify_x(self):
        for layer in self.layers:
            nodes_sorted = sorted(layer, key=lambda node: self.G.nodes[node]['x'])
            i_middle = len(nodes_sorted) // 2
            delta = len(nodes_sorted) % 2
            for i in range(len(nodes_sorted)):
                self.G.nodes[nodes_sorted[i]]['x'] = (1 - delta) + (i-i_middle)*2          
            
    def plot_digraph(self):
        x_arr = [self.G.nodes[node]['x'] for node in self.G.nodes if not self.G.nodes[node]['is_dummy']]
        y_arr = [self.G.nodes[node]['layer'] for node in self.G.nodes if not self.G.nodes[node]['is_dummy']]
        fig = plt.figure(figsize=(25, 15))
        ax = fig.add_subplot(111)
        ax.scatter(x_arr, y_arr, marker='o', s=850, c='cyan')
        
        for start in self.G.nodes:
            for end in self.G.neighbors(start):
                x1 = self.G.nodes[start]['x']
                y1 = self.G.nodes[start]['layer']
                x2 = self.G.nodes[end]['x']
                y2 = self.G.nodes[end]['layer']
                ax.arrow(
                    x1, y1, x2-x1, y2-y1, shape='full', color='lime', 
                         length_includes_head=True, head_width=.05)
                ax.plot([x1,x2], [y1,y2], linestyle='-', color='lime')
                
        for node in self.G.nodes:
            x = self.G.nodes[node]['x']
            y = self.G.nodes[node]['layer']
            label = self.G.nodes[node]['label']
            plt.text(
                x=x-0.1, y=y-0.08, s=label,
                #x=x, y=y, s=label,
                #bbox=dict(facecolor='green',alpha=0.7),
                fontdict=dict(color='black',size=18),   
            )
        #plt.axis('off')
        plt.grid()
        plt.show()

g = DiGraph(path='tr1.xml')
g.visualize(max_width=4)
g.plot_digraph()

g = DiGraph(path='tr1.xml')
g.visualize(max_width=None)
g.plot_digraph()

tr2 = """<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
  http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
  <graph id="tree" edgedefault="directed">
    <node id="n1"/>
    <node id="n2"/>
    <node id="n3"/>
    <node id="n4"/>
    <node id="n5"/>
    <node id="n6"/>
    <node id="n7"/>
    <node id="n8"/>
    <node id="n9"/>
    <node id="n10"/>
    <node id="n11"/>
    <node id="n12"/>
    <node id="n13"/>
    <node id="n14"/>
    <node id="n15"/>
    <node id="n16"/>
    <node id="n17"/>
    <node id="n18"/>
    <node id="n19"/>
    <node id="n20"/>
    <node id="n21"/>
    <node id="n22"/>
    <node id="n23"/>
    <node id="n24"/>
    <node id="n25"/>
    <node id="n26"/>
    <node id="n27"/>
    <node id="n28"/>
    <node id="n29"/>
    <node id="n30"/>
    <node id="n31"/>
    <node id="n32"/>
    <node id="n33"/>
    <node id="n34"/>
    <node id="n35"/>
    <node id="n36"/>
    <node id="n37"/>
    <node id="n38"/>
    <node id="n39"/>
    <node id="n40"/>
    <node id="n41"/>
    <node id="n42"/>
    <node id="n43"/>
    <node id="n44"/>
    <node id="n45"/>
    <node id="n46"/>
    <node id="n47"/>
    <node id="n48"/>
    <node id="n49"/>
    <node id="n50"/>
    <node id="n51"/>
    <node id="n52"/>
    <node id="n53"/>
    <node id="n54"/>
    <node id="n55"/>
    <node id="n56"/>
    <node id="n57"/>
    <node id="n58"/>
    <node id="n59"/>
    <edge source="n1" target="n2"/>
    <edge source="n1" target="n11"/>
    <edge source="n2" target="n3"/>
    <edge source="n2" target="n6"/>
    <edge source="n3" target="n4"/>
    <edge source="n3" target="n5"/>
    <edge source="n6" target="n7"/>
    <edge source="n7" target="n8"/>
    <edge source="n7" target="n9"/>
    <edge source="n9" target="n10"/>
    <edge source="n11" target="n12"/>
    <edge source="n11" target="n37"/>
    <edge source="n12" target="n13"/>
    <edge source="n12" target="n30"/>
    <edge source="n13" target="n14"/>
    <edge source="n13" target="n20"/>
    <edge source="n14" target="n15"/>
    <edge source="n14" target="n18"/>
    <edge source="n15" target="n16"/>
    <edge source="n16" target="n17"/>
    <edge source="n18" target="n19"/>
    <edge source="n20" target="n21"/>
    <edge source="n21" target="n22"/>
    <edge source="n21" target="n25"/>
    <edge source="n22" target="n23"/>
    <edge source="n23" target="n24"/>
    <edge source="n25" target="n26"/>
    <edge source="n25" target="n28"/>
    <edge source="n26" target="n27"/>
    <edge source="n28" target="n29"/>
    <edge source="n30" target="n31"/>
    <edge source="n30" target="n32"/>
    <edge source="n32" target="n33"/>
    <edge source="n32" target="n34"/>
    <edge source="n34" target="n35"/>
    <edge source="n35" target="n36"/>
    <edge source="n37" target="n38"/>
    <edge source="n37" target="n42"/>
    <edge source="n38" target="n39"/>
    <edge source="n39" target="n40"/>
    <edge source="n40" target="n41"/>
    <edge source="n42" target="n43"/>
    <edge source="n42" target="n45"/>
    <edge source="n43" target="n44"/>
    <edge source="n45" target="n46"/>
    <edge source="n45" target="n47"/>
    <edge source="n48" target="n49"/>
    <edge source="n48" target="n58"/>
    <edge source="n49" target="n50"/>
    <edge source="n49" target="n54"/>
    <edge source="n50" target="n51"/>
    <edge source="n51" target="n52"/>
    <edge source="n51" target="n53"/>
    <edge source="n54" target="n55"/>
    <edge source="n55" target="n56"/>
    <edge source="n56" target="n57"/>
    <edge source="n58" target="n59"/>
  </graph>
</graphml>"""

with open('./tr2.xml', 'w') as file:
    file.write(tr2)

g = DiGraph(path='tr2.xml')
g.visualize(max_width=6)
g.plot_digraph()

g = DiGraph(path='tr2.xml')
g.visualize(max_width=2)
g.plot_digraph()